<!--
  Copyright (c) 2006-2013, JGraph Ltd

  Hello, World! example for mxGraph. This example demonstrates using
  the isPort hook for visually connecting to another Edge.
-->
<html>
<head>
	<title>Dessia Workflow</title>

	<!-- Sets the basepath for the library if not in same directory -->
	<script type="text/javascript">
		mxBasePath = '{{mx_path}}';
	</script>

	<!-- Loads and initializes the library -->
	<script type="text/javascript" src="{{mx_path}}/js/mxClient.js"></script>

	<!-- Example code -->
	<script type="text/javascript">
		// Program starts here. Creates a sample graph in the
		// DOM node with the specified ID. This function is invoked
		// from the onLoad event handler of the document (see below).
		function main(container)
		{
			// Checks if the browser is supported
			if (!mxClient.isBrowserSupported())
			{
				// Displays an error message if the browser is not supported.
				mxUtils.error('Browser is not supported!', 200, false);
			}
			else
			{
				// Creates the graph inside the given container
				var graph = new mxGraph(container);
				graph.setConnectable(true);
				graph.setTooltips(true);
				graph.setPanning(true);
				graph.setAllowDanglingEdges(true);
				graph.setDisconnectOnMove(false);


				// Sets the default edge style
				var edgeStyle = graph.getStylesheet().getDefaultEdgeStyle();
				edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
				edgeStyle[mxConstants.STYLE_STROKECOLOR] = '#537CB0';
				edgeStyle[mxConstants.STYLE_ROUNDED] = true;

				// Uses the entity perimeter (below) as default
				edgeStyle[mxConstants.STYLE_VERTICAL_ALIGN] = mxConstants.ALIGN_TOP;

				var vertexStyle = graph.getStylesheet().getDefaultVertexStyle();

				vertexStyle[mxConstants.STYLE_FILLCOLOR] = '#FFF';
				vertexStyle[mxConstants.STYLE_STROKECOLOR] = '#537CB0';
				mxConstants.DEFAULT_VALID_COLOR = '#FFCC00';
				mxConstants.VERTEX_SELECTION_COLOR = '#FFCC00';
				mxConstants.EDGE_SELECTION_COLOR = '#FFCC00';
				mxConstants.HANDLE_FILLCOLOR = '#FFCC00';

				vertexStyle[mxConstants.STYLE_ROUNDED] = true;

				// Ports are not used as terminals for edges, they are
				// only used to compute the graphical connection point
				graph.isPort = function(cell)
				{
					var geo = this.getCellGeometry(cell);

					return (geo != null) ? geo.relative : false;
				};

				// Implements a tooltip that shows the actual
				// source and target of an edge
				graph.getTooltipForCell = function(cell)
				{
					if (this.model.isEdge(cell))
					{
						return this.convertValueToString(this.model.getTerminal(cell, true)) + ' => ' +
							this.convertValueToString(this.model.getTerminal(cell, false))
					}

					return mxGraph.prototype.getTooltipForCell.apply(this, arguments);
				};

				// Removes the folding icon and disables any folding
				graph.isCellFoldable = function(cell)
				{
					return false;
				};

				// Enables rubberband selection
				// new mxRubberband(graph);

				// Gets the default parent for inserting new cells. This
				// is normally the first child of the root (ie. layer 0).
				var parent = graph.getDefaultParent();

				// Adds cells to the model in a single step
				graph.getModel().beginUpdate();
				try
				{
					var blocks = [];
					var input_ports = [];
					var output_ports = [];

					var js_nodes = [];
					var js_edges = [];

					{% for node in nodes %}
						var js_node = graph.insertVertex(parent, null, '{{node['name']}}', 50, 50, 200, 80);
						js_nodes.push(js_node)
						var input_ports_node = [];
						var n_inputs = {{node['inputs']|length}};
						var output_ports_node = [];
						var n_outputs = {{node['outputs']|length}};

						{% for input in node['inputs'] %}
							var port = graph.insertVertex(js_node, null, '{{input['name']}}', 0, ({{loop.index}})/(1+n_inputs), 10, 10);
							input_ports_node.push(port);
						{% endfor %}
						input_ports.push(input_ports_node);

						{% for output in node['outputs'] %}
							var port = graph.insertVertex(js_node, null, '{{output['name']}}', 1, ({{loop.index}})/(1+n_outputs), 10, 10);
							output_ports_node.push(port);
						{% endfor %}
						output_ports.push(output_ports_node);
					{% endfor %}

					for (let [i_node, js_node] of js_nodes.entries()){
						for (let port of js_node.children){
							if (input_ports[i_node].indexOf(port)>=0){
								port.geometry.offset = new mxPoint(-5, -5);
								port.geometry.relative = true;
								var align = "left";
								var color = "#FF0000";
							}
							else if (output_ports[i_node].indexOf(port)>=0){
								port.geometry.offset = new mxPoint(-5, -5);
								port.geometry.relative = true;
								var align = "right";
								var color = "#C0C0C0";
							}
							port.style = 'align='+align+';verticalAlign=middle;fontSize=10;routingCenterX=-0.5;'+
								'spacingLeft=12;fillColor='+color;
						}
					}

					{% for edge in edges %}
						{% if not edge[0][1] %}
								var port1 = input_ports[{{edge[0][0]}}][{{edge[0][2]}}];
						{% else %}
								var port1 = output_ports[{{edge[0][0]}}][{{edge[0][2]}}];
						{% endif %}
						{% if not edge[1][1] %}
								var port2 = input_ports[{{edge[1][0]}}][{{edge[1][2]}}];
						{% else %}
								var port2 = output_ports[{{edge[1][0]}}][{{edge[1][2]}}];
						{% endif %}

						var js_edge = graph.insertEdge(parent, null, '', port1, port2);
						js_edges.push(js_edge);
					{% endfor %}


				// layout.execute(parent);
				graph.refresh();

				}
				finally
				{
					// Updates the display
					graph.getModel().endUpdate();
				}
			}
		};
	</script>
</head>

<!-- Page passes the container for the graph to the program -->
<body onload="main(document.getElementById('graphContainer'))">

	<!-- Creates a container for the graph with a grid wallpaper -->
	<div id="graphContainer"
		style="overflow:hidden;width:auto;height:auto;background:url('editors/images/grid.gif');cursor:default;margin:30px;">
	</div>
</body>
</html>
